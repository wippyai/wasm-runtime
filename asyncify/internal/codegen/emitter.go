// Package codegen provides low-level WASM bytecode emission utilities for asyncify.
//
// This package contains the Emitter type which provides a fluent API for generating
// WebAssembly bytecode. It encapsulates common patterns used in asyncify transformation
// and provides type-safe instruction emission.
//
// The design goals are:
//   - Fluent API that chains method calls for readability
//   - Type-safe emission of instructions with proper immediates
//   - Encapsulation of common asyncify patterns (state checks, memory ops)
//   - Zero allocations for common operations where possible
//   - Clear separation from instruction handling logic
//
// Example usage:
//
//	e := codegen.NewEmitter()
//	e.GlobalGet(stateIdx).
//	    I32Const(StateNormal).
//	    I32Eq().
//	    If(BlockVoid)
//	// ... emit body ...
//	e.End()
//	return e.Bytes()
package codegen

import (
	"bytes"
	"sync"

	"github.com/wippyai/wasm-runtime/wasm"
)

// emitterPool provides reusable Emitter instances to reduce allocations.
var emitterPool = sync.Pool{
	New: func() interface{} {
		return &Emitter{}
	},
}

// Block type constants for clarity in emission code.
// These map to the WASM block type encoding where negative values
// indicate inline types and non-negative indicate type indices.
const (
	BlockVoid int32 = -64 // No result
	BlockI32  int32 = -1  // Returns i32
	BlockI64  int32 = -2  // Returns i64
	BlockF32  int32 = -3  // Returns f32
	BlockF64  int32 = -4  // Returns f64
)

// Emitter provides a fluent API for generating WebAssembly bytecode.
//
// All instruction methods return the Emitter itself to enable method chaining.
// The generated bytecode can be retrieved with Bytes() or written to the
// underlying buffer directly with Raw().
//
// Emitter is not safe for concurrent use. Create separate instances for
// concurrent code generation.
type Emitter struct {
	buf bytes.Buffer
}

// NewEmitter creates a new Emitter with an empty buffer.
//
// The returned Emitter is ready for immediate use. Call Bytes() when done
// to retrieve the generated bytecode.
func NewEmitter() *Emitter {
	return &Emitter{}
}

// NewEmitterWithCapacity creates a new Emitter with pre-allocated buffer capacity.
//
// Use this when the approximate output size is known to reduce allocations.
// The capacity is a hint; the buffer will grow if needed.
func NewEmitterWithCapacity(capacity int) *Emitter {
	e := &Emitter{}
	e.buf.Grow(capacity)
	return e
}

// GetEmitter returns an Emitter from the pool, ready for use.
// The returned Emitter has an empty buffer.
// Call PutEmitter when done to return it to the pool.
func GetEmitter() *Emitter {
	e := emitterPool.Get().(*Emitter)
	e.buf.Reset()
	return e
}

// GetEmitterWithCapacity returns an Emitter from the pool with pre-grown capacity.
// Call PutEmitter when done to return it to the pool.
func GetEmitterWithCapacity(capacity int) *Emitter {
	e := emitterPool.Get().(*Emitter)
	e.buf.Reset()
	if e.buf.Cap() < capacity {
		e.buf.Grow(capacity - e.buf.Len())
	}
	return e
}

// PutEmitter returns an Emitter to the pool for reuse.
// The Emitter must not be used after calling PutEmitter.
func PutEmitter(e *Emitter) {
	if e == nil {
		return
	}
	e.buf.Reset()
	emitterPool.Put(e)
}

// Bytes returns the generated bytecode as a byte slice.
//
// The returned slice references the internal buffer. Do not modify it
// after calling other Emitter methods or it may become invalid.
// Call Copy() if you need an independent copy.
func (e *Emitter) Bytes() []byte {
	return e.buf.Bytes()
}

// Copy returns an independent copy of the generated bytecode.
//
// Unlike Bytes(), the returned slice is safe to use after further
// Emitter operations.
func (e *Emitter) Copy() []byte {
	out := make([]byte, e.buf.Len())
	copy(out, e.buf.Bytes())
	return out
}

// Len returns the current length of the generated bytecode in bytes.
func (e *Emitter) Len() int {
	return e.buf.Len()
}

// Reset clears the internal buffer for reuse.
//
// After Reset, the Emitter can be reused as if newly created.
// This is more efficient than creating a new Emitter when generating
// multiple independent bytecode sequences.
func (e *Emitter) Reset() *Emitter {
	e.buf.Reset()
	return e
}

// Raw writes raw bytes directly to the buffer.
//
// Use this for pre-encoded instruction sequences or to embed
// bytecode from other sources. No validation is performed.
func (e *Emitter) Raw(data []byte) *Emitter {
	_, _ = e.buf.Write(data)
	return e
}

// emit encodes and writes a single instruction directly to the buffer
func (e *Emitter) emit(instr wasm.Instruction) *Emitter {
	wasm.EncodeInstructionTo(&e.buf, &instr)
	return e
}

// ============================================================================
// Control Flow Instructions
// ============================================================================

// Unreachable emits the unreachable instruction (0x00).
//
// This instruction always traps. Use it to mark code paths that should
// never be reached (e.g., after an unconditional branch).
func (e *Emitter) Unreachable() *Emitter {
	_ = e.buf.WriteByte(wasm.OpUnreachable)
	return e
}

// Nop emits the nop instruction (0x01).
//
// No operation. Useful for padding or as a placeholder.
func (e *Emitter) Nop() *Emitter {
	_ = e.buf.WriteByte(wasm.OpNop)
	return e
}

// Block emits a block instruction with the specified result type.
//
// Use BlockVoid, BlockI32, BlockI64, BlockF32, BlockF64 constants
// or a non-negative type index. Must be matched with End().
func (e *Emitter) Block(resultType int32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpBlock, Imm: wasm.BlockImm{Type: resultType}})
}

// Loop emits a loop instruction with the specified result type.
//
// Unlike Block, branching to a Loop jumps to the beginning.
// Must be matched with End().
func (e *Emitter) Loop(resultType int32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpLoop, Imm: wasm.BlockImm{Type: resultType}})
}

// If emits an if instruction with the specified result type.
//
// Consumes an i32 from the stack. If non-zero, executes the then branch.
// Can be followed by Else() for a two-branch conditional.
// Must be matched with End().
func (e *Emitter) If(resultType int32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpIf, Imm: wasm.BlockImm{Type: resultType}})
}

// Else emits the else instruction inside an if block.
//
// Separates the then and else branches of an If block.
func (e *Emitter) Else() *Emitter {
	_ = e.buf.WriteByte(wasm.OpElse)
	return e
}

// End emits the end instruction that closes a Block, Loop, If, or function.
func (e *Emitter) End() *Emitter {
	e.buf.WriteByte(wasm.OpEnd)
	return e
}

// Br emits an unconditional branch to the specified label depth.
//
// Label 0 is the innermost enclosing block. Each outer block adds 1.
func (e *Emitter) Br(labelIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpBr, Imm: wasm.BranchImm{LabelIdx: labelIdx}})
}

// BrIf emits a conditional branch to the specified label depth.
//
// Consumes an i32 from the stack. Branches if non-zero.
func (e *Emitter) BrIf(labelIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpBrIf, Imm: wasm.BranchImm{LabelIdx: labelIdx}})
}

// BrTable emits a branch table instruction for indexed branching.
//
// Consumes an i32 index from the stack. If in range [0, len(labels)),
// branches to labels[index]. Otherwise branches to defaultLabel.
func (e *Emitter) BrTable(labels []uint32, defaultLabel uint32) *Emitter {
	return e.emit(wasm.Instruction{
		Opcode: wasm.OpBrTable,
		Imm:    wasm.BrTableImm{Labels: labels, Default: defaultLabel},
	})
}

// Return emits a return instruction to exit the current function.
func (e *Emitter) Return() *Emitter {
	e.buf.WriteByte(wasm.OpReturn)
	return e
}

// Call emits a direct function call.
//
// The funcIdx is the function index in the module's function index space
// (imports first, then defined functions).
func (e *Emitter) Call(funcIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpCall, Imm: wasm.CallImm{FuncIdx: funcIdx}})
}

// CallIndirect emits an indirect function call through a table.
//
// Consumes an i32 table index from the stack. The function at that
// table slot must match the specified type signature.
func (e *Emitter) CallIndirect(typeIdx, tableIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{
		Opcode: wasm.OpCallIndirect,
		Imm:    wasm.CallIndirectImm{TypeIdx: typeIdx, TableIdx: tableIdx},
	})
}

// ============================================================================
// Parametric Instructions
// ============================================================================

// Drop emits a drop instruction to discard the top stack value.
func (e *Emitter) Drop() *Emitter {
	e.buf.WriteByte(wasm.OpDrop)
	return e
}

// Select emits a select instruction (ternary operator).
//
// Consumes three values: condition (i32), false-value, true-value.
// Produces the true-value if condition is non-zero, otherwise false-value.
func (e *Emitter) Select() *Emitter {
	e.buf.WriteByte(wasm.OpSelect)
	return e
}

// ============================================================================
// Variable Access Instructions
// ============================================================================

// LocalGet emits a local.get instruction to read a local variable.
//
// The localIdx includes parameters (0..N-1) and local variables (N+).
func (e *Emitter) LocalGet(localIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpLocalGet, Imm: wasm.LocalImm{LocalIdx: localIdx}})
}

// LocalSet emits a local.set instruction to write a local variable.
//
// Consumes the top stack value and stores it in the local.
func (e *Emitter) LocalSet(localIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpLocalSet, Imm: wasm.LocalImm{LocalIdx: localIdx}})
}

// LocalTee emits a local.tee instruction (write + keep on stack).
//
// Like LocalSet but also leaves the value on the stack.
func (e *Emitter) LocalTee(localIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpLocalTee, Imm: wasm.LocalImm{LocalIdx: localIdx}})
}

// GlobalGet emits a global.get instruction to read a global variable.
func (e *Emitter) GlobalGet(globalIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpGlobalGet, Imm: wasm.GlobalImm{GlobalIdx: globalIdx}})
}

// GlobalSet emits a global.set instruction to write a global variable.
//
// The global must be mutable (mut keyword in type declaration).
func (e *Emitter) GlobalSet(globalIdx uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpGlobalSet, Imm: wasm.GlobalImm{GlobalIdx: globalIdx}})
}

// ============================================================================
// Memory Instructions
// ============================================================================

// I32Load emits an i32.load instruction.
//
// Loads a 32-bit value from memory at the effective address:
// (stack operand) + offset. Align is 2^align bytes (0=1, 1=2, 2=4).
func (e *Emitter) I32Load(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpI32Load, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// I64Load emits an i64.load instruction.
func (e *Emitter) I64Load(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpI64Load, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// F32Load emits an f32.load instruction.
func (e *Emitter) F32Load(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpF32Load, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// F64Load emits an f64.load instruction.
func (e *Emitter) F64Load(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpF64Load, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// I32Store emits an i32.store instruction.
//
// Stores a 32-bit value to memory at the effective address.
// Consumes address (i32) and value (i32) from the stack.
func (e *Emitter) I32Store(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpI32Store, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// I64Store emits an i64.store instruction.
func (e *Emitter) I64Store(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpI64Store, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// F32Store emits an f32.store instruction.
func (e *Emitter) F32Store(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpF32Store, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// F64Store emits an f64.store instruction.
func (e *Emitter) F64Store(align, offset uint32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpF64Store, Imm: wasm.MemoryImm{Align: align, Offset: uint64(offset)}})
}

// MemorySize emits a memory.size instruction.
//
// Pushes the current memory size in pages (64KB each).
func (e *Emitter) MemorySize() *Emitter {
	// memory.size has a 0x00 byte for the memory index
	e.buf.WriteByte(wasm.OpMemorySize)
	e.buf.WriteByte(0x00)
	return e
}

// MemoryGrow emits a memory.grow instruction.
//
// Consumes a page count (i32), returns previous size or -1 on failure.
func (e *Emitter) MemoryGrow() *Emitter {
	e.buf.WriteByte(wasm.OpMemoryGrow)
	e.buf.WriteByte(0x00)
	return e
}

// ============================================================================
// Constant Instructions
// ============================================================================

// I32Const emits an i32.const instruction with the given value.
func (e *Emitter) I32Const(value int32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpI32Const, Imm: wasm.I32Imm{Value: value}})
}

// I64Const emits an i64.const instruction with the given value.
func (e *Emitter) I64Const(value int64) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpI64Const, Imm: wasm.I64Imm{Value: value}})
}

// F32Const emits an f32.const instruction with the given value.
func (e *Emitter) F32Const(value float32) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpF32Const, Imm: wasm.F32Imm{Value: value}})
}

// F64Const emits an f64.const instruction with the given value.
func (e *Emitter) F64Const(value float64) *Emitter {
	return e.emit(wasm.Instruction{Opcode: wasm.OpF64Const, Imm: wasm.F64Imm{Value: value}})
}

// EmitV128Const emits a v128.const instruction with the given 16-byte value.
func (e *Emitter) EmitV128Const(value [16]byte) *Emitter {
	return e.emit(wasm.Instruction{
		Opcode: wasm.OpPrefixSIMD,
		Imm:    wasm.SIMDImm{SubOpcode: 0x0C, V128Bytes: value[:]},
	})
}

// RefNullFunc emits a ref.null funcref instruction.
func (e *Emitter) RefNullFunc() *Emitter {
	return e.emit(wasm.Instruction{
		Opcode: wasm.OpRefNull,
		Imm:    wasm.RefNullImm{HeapType: int64(wasm.ValFuncRef)},
	})
}

// RefNullExtern emits a ref.null externref instruction.
func (e *Emitter) RefNullExtern() *Emitter {
	return e.emit(wasm.Instruction{
		Opcode: wasm.OpRefNull,
		Imm:    wasm.RefNullImm{HeapType: int64(wasm.ValExtern)},
	})
}

// ============================================================================
// Comparison Instructions (i32)
// ============================================================================

// I32Eqz emits an i32.eqz instruction (test if zero).
func (e *Emitter) I32Eqz() *Emitter {
	e.buf.WriteByte(wasm.OpI32Eqz)
	return e
}

// I32Eq emits an i32.eq instruction (equality comparison).
func (e *Emitter) I32Eq() *Emitter {
	e.buf.WriteByte(wasm.OpI32Eq)
	return e
}

// I32Ne emits an i32.ne instruction (inequality comparison).
func (e *Emitter) I32Ne() *Emitter {
	e.buf.WriteByte(wasm.OpI32Ne)
	return e
}

// I32LtS emits an i32.lt_s instruction (signed less than).
func (e *Emitter) I32LtS() *Emitter {
	e.buf.WriteByte(wasm.OpI32LtS)
	return e
}

// I32LtU emits an i32.lt_u instruction (unsigned less than).
func (e *Emitter) I32LtU() *Emitter {
	e.buf.WriteByte(wasm.OpI32LtU)
	return e
}

// I32GtS emits an i32.gt_s instruction (signed greater than).
func (e *Emitter) I32GtS() *Emitter {
	e.buf.WriteByte(wasm.OpI32GtS)
	return e
}

// I32GtU emits an i32.gt_u instruction (unsigned greater than).
func (e *Emitter) I32GtU() *Emitter {
	e.buf.WriteByte(wasm.OpI32GtU)
	return e
}

// I32LeS emits an i32.le_s instruction (signed less or equal).
func (e *Emitter) I32LeS() *Emitter {
	e.buf.WriteByte(wasm.OpI32LeS)
	return e
}

// I32LeU emits an i32.le_u instruction (unsigned less or equal).
func (e *Emitter) I32LeU() *Emitter {
	e.buf.WriteByte(wasm.OpI32LeU)
	return e
}

// I32GeS emits an i32.ge_s instruction (signed greater or equal).
func (e *Emitter) I32GeS() *Emitter {
	e.buf.WriteByte(wasm.OpI32GeS)
	return e
}

// I32GeU emits an i32.ge_u instruction (unsigned greater or equal).
func (e *Emitter) I32GeU() *Emitter {
	e.buf.WriteByte(wasm.OpI32GeU)
	return e
}

// ============================================================================
// Arithmetic Instructions (i32)
// ============================================================================

// I32Add emits an i32.add instruction.
func (e *Emitter) I32Add() *Emitter {
	e.buf.WriteByte(wasm.OpI32Add)
	return e
}

// I32Sub emits an i32.sub instruction.
func (e *Emitter) I32Sub() *Emitter {
	e.buf.WriteByte(wasm.OpI32Sub)
	return e
}

// I32Mul emits an i32.mul instruction.
func (e *Emitter) I32Mul() *Emitter {
	e.buf.WriteByte(wasm.OpI32Mul)
	return e
}

// I32DivS emits an i32.div_s instruction (signed division).
func (e *Emitter) I32DivS() *Emitter {
	e.buf.WriteByte(wasm.OpI32DivS)
	return e
}

// I32DivU emits an i32.div_u instruction (unsigned division).
func (e *Emitter) I32DivU() *Emitter {
	e.buf.WriteByte(wasm.OpI32DivU)
	return e
}

// I32And emits an i32.and instruction (bitwise AND).
func (e *Emitter) I32And() *Emitter {
	e.buf.WriteByte(wasm.OpI32And)
	return e
}

// I32Or emits an i32.or instruction (bitwise OR).
func (e *Emitter) I32Or() *Emitter {
	e.buf.WriteByte(wasm.OpI32Or)
	return e
}

// I32Xor emits an i32.xor instruction (bitwise XOR).
func (e *Emitter) I32Xor() *Emitter {
	e.buf.WriteByte(wasm.OpI32Xor)
	return e
}

// I32Shl emits an i32.shl instruction (left shift).
func (e *Emitter) I32Shl() *Emitter {
	e.buf.WriteByte(wasm.OpI32Shl)
	return e
}

// I32ShrS emits an i32.shr_s instruction (signed right shift).
func (e *Emitter) I32ShrS() *Emitter {
	e.buf.WriteByte(wasm.OpI32ShrS)
	return e
}

// I32ShrU emits an i32.shr_u instruction (unsigned right shift).
func (e *Emitter) I32ShrU() *Emitter {
	e.buf.WriteByte(wasm.OpI32ShrU)
	return e
}

// ============================================================================
// Comparison Instructions (i64)
// ============================================================================

// I64Eqz emits an i64.eqz instruction.
func (e *Emitter) I64Eqz() *Emitter {
	e.buf.WriteByte(wasm.OpI64Eqz)
	return e
}

// I64Eq emits an i64.eq instruction.
func (e *Emitter) I64Eq() *Emitter {
	e.buf.WriteByte(wasm.OpI64Eq)
	return e
}

// I64Ne emits an i64.ne instruction.
func (e *Emitter) I64Ne() *Emitter {
	e.buf.WriteByte(wasm.OpI64Ne)
	return e
}

// ============================================================================
// Arithmetic Instructions (i64)
// ============================================================================

// I64Add emits an i64.add instruction.
func (e *Emitter) I64Add() *Emitter {
	e.buf.WriteByte(wasm.OpI64Add)
	return e
}

// I64Sub emits an i64.sub instruction.
func (e *Emitter) I64Sub() *Emitter {
	e.buf.WriteByte(wasm.OpI64Sub)
	return e
}

// I64Mul emits an i64.mul instruction.
func (e *Emitter) I64Mul() *Emitter {
	e.buf.WriteByte(wasm.OpI64Mul)
	return e
}

// I64And emits an i64.and instruction.
func (e *Emitter) I64And() *Emitter {
	e.buf.WriteByte(wasm.OpI64And)
	return e
}

// I64Or emits an i64.or instruction.
func (e *Emitter) I64Or() *Emitter {
	e.buf.WriteByte(wasm.OpI64Or)
	return e
}

// ============================================================================
// Arithmetic Instructions (f32/f64)
// ============================================================================

// F32Add emits an f32.add instruction.
func (e *Emitter) F32Add() *Emitter {
	e.buf.WriteByte(wasm.OpF32Add)
	return e
}

// F64Add emits an f64.add instruction.
func (e *Emitter) F64Add() *Emitter {
	e.buf.WriteByte(wasm.OpF64Add)
	return e
}

// ============================================================================
// Conversion Instructions
// ============================================================================

// I32WrapI64 emits an i32.wrap_i64 instruction.
func (e *Emitter) I32WrapI64() *Emitter {
	e.buf.WriteByte(wasm.OpI32WrapI64)
	return e
}

// I64ExtendI32S emits an i64.extend_i32_s instruction (signed extension).
func (e *Emitter) I64ExtendI32S() *Emitter {
	e.buf.WriteByte(wasm.OpI64ExtendI32S)
	return e
}

// I64ExtendI32U emits an i64.extend_i32_u instruction (unsigned extension).
func (e *Emitter) I64ExtendI32U() *Emitter {
	e.buf.WriteByte(wasm.OpI64ExtendI32U)
	return e
}

// ============================================================================
// Asyncify-Specific Compound Instructions
// ============================================================================

// StateCheck emits: global.get(stateIdx), i32.const(stateValue), i32.eq
//
// This is a common pattern in asyncify to check if the current state
// matches the expected value. The result is left on the stack as i32 (0/1).
func (e *Emitter) StateCheck(stateGlobalIdx uint32, expectedState int32) *Emitter {
	return e.GlobalGet(stateGlobalIdx).I32Const(expectedState).I32Eq()
}

// IfState emits: state_check + if (block_type)
//
// Opens a conditional block that executes only when the asyncify state
// matches the expected value. Must be matched with End().
func (e *Emitter) IfState(stateGlobalIdx uint32, expectedState int32, resultType int32) *Emitter {
	return e.StateCheck(stateGlobalIdx, expectedState).If(resultType)
}

// LoadStackPtr emits code to load the current asyncify stack pointer.
//
// The dataGlobalIdx should be the asyncify data pointer global.
// Stack layout: [stack_ptr (offset 0), stack_end (offset 4), data...]
// After execution, stack_ptr value is on the stack.
func (e *Emitter) LoadStackPtr(dataGlobalIdx uint32) *Emitter {
	return e.GlobalGet(dataGlobalIdx).I32Load(2, 0)
}

// StoreStackPtr emits code to store a new asyncify stack pointer.
//
// Expects the new stack_ptr value on the stack. Consumes it.
func (e *Emitter) StoreStackPtr(dataGlobalIdx uint32, stackPtrLocal uint32) *Emitter {
	return e.GlobalGet(dataGlobalIdx).LocalGet(stackPtrLocal).I32Store(2, 0)
}

// IncrStackPtr emits code to increment the stack pointer by a fixed offset.
//
// Loads stack_ptr, adds offset, stores back to stack_ptr location.
// The stack_ptr location is at offset 0 of the data structure.
func (e *Emitter) IncrStackPtr(dataGlobalIdx uint32, offset int32) *Emitter {
	return e.GlobalGet(dataGlobalIdx).
		GlobalGet(dataGlobalIdx).
		I32Load(2, 0).
		I32Const(offset).
		I32Add().
		I32Store(2, 0)
}

// EmitInstr emits a pre-constructed wasm.Instruction.
//
// Use this to emit instructions that don't have dedicated methods
// or to pass through instructions from decoded bytecode.
func (e *Emitter) EmitInstr(instr wasm.Instruction) *Emitter {
	return e.emit(instr)
}

// EmitInstrs emits multiple pre-constructed instructions.
//
// Equivalent to calling EmitInstr for each instruction.
func (e *Emitter) EmitInstrs(instrs []wasm.Instruction) *Emitter {
	wasm.EncodeInstructionsTo(&e.buf, instrs)
	return e
}

// EmitRawOpcode emits a single opcode byte with no immediate.
//
// For simple opcodes that have no operands.
func (e *Emitter) EmitRawOpcode(opcode byte) *Emitter {
	e.buf.WriteByte(opcode)
	return e
}
